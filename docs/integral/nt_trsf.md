# APIs

## transform(a, 0):

$ f ( q ) = \sum _ { i = 0 } ^ N a _ i q ^ i $ の係数列 $ a $ を入力すると、
$ b _ i = f ( \zeta ^ i ) $ の列を出力します。ただし、$ \zeta $ は 1 の原始 N 乗根です。

また、N が 2 冪でないときには、実行時エラーになります。


## transform(a, 1)

同じことを、先ほどの $ \zeta $ の代わりにその逆元を用いて行います。


## multiply(a, b)

多項式の積を計算します。

入力の長さは 2 冪でなくともよく、出力の長さも 2 冪とは限りません。
答えが 0 のときには空を返します。


## TODO

現状 `multiply` は、`transform(_, 0)` をして成分ごとに積を取り、`transform(_, 1)` をしています。
また、`transform` は、ビット反転をしたあとでバタフライ変換をしています。

一方、成分ごとの積を取る操作は成分の順番を入れ替えても大丈夫です。
ですから、初めにバタフライ変換のビット反転による共役を施し、成分積をとり、そのあとで普通の逆元バタフライ変換をすると無駄がなさそうです。

実行時間的には、そもそもボトルネックではないですから、変わらないと思うのですが、ビット反転はないほうが美しそうです。

